\subsection{Variable et mutabilit√©}
\begin{frame}[fragile]
Par d√©faut, les variables dans Rust sont immutables.
  \begin{lstlisting}[language=rust]
{
    let x = 5;
    x = 6;
}
  \end{lstlisting}
  \begin{lstlisting}[language=bash]
error[E0384]: cannot assign twice
  to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable
               variable
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  Le mot-cl√© \texttt{mut} permet de d√©clarer une variable mutable.
  \begin{lstlisting}[language=rust]
{
    let mut x = 5;
    x = 6;
}
  \end{lstlisting}

  \begin{lstlisting}[language=bash]
> cargo build
Compiling variables v0.1.0
(file:///projects/variables)
Finished dev [unoptimized + debuginfo]
target(s) in 0.30 secs
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constantes}
Les constantes sont toujours immutables et ne peuvent pas utilis√©es avec le mot-cl√© `mut`.
\begin{lstlisting}[language=rust]
const MAX_POINTS: u32 = 100_000;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Masquage de nom}
On peut d√©clarer une nouvelle variable du m√™me nom qu'une autre la pr√©c√©dent, ce qui cache l'ancienne valeur associ√©e √† ce nom dans la zone d'√©xecution courante.
\begin{lstlisting}[language=rust]
let x = 5;
let x = x + 1;
\end{lstlisting}
Ce concept permet notamment de changer le type de la valeur associ√©e √† un nom au fil du programme, ce qui dans certains cas peut √™tre tr√®s pratique et plus lisible.
\begin{lstlisting}[language=rust]
let spaces = "   ";
let spaces = spaces.len();
\end{lstlisting}
\end{frame}

\subsection{Types de donn√©es primitifs}
\begin{frame}[fragile]
  \frametitle{Types simples}
  \begin{lstlisting}
{
    let i: i8 = 127; // i16, i32, i64, i128, isize
    let u: u8 = 255; // u16, u32, u64, u128, usize
    
    let f: f32 = 5.0; // f64
    
    let b: bool = true;
    
    let c: char = 'c';
    let heart_eyed_cat = 'üòª';
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types compos√©s}
On peut d√©finir des tuples de valeurs ayant des types distincts.
  \begin{lstlisting}[language=rust]
{
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (x, y, z) = tup;
    
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types compos√©s}
  \begin{lstlisting}[language=rust]
{
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    let element = a[10];
}
  \end{lstlisting}
  \begin{lstlisting}[language=bash, basicstyle=\tiny{}]
> cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
  \end{lstlisting}
\end{frame}

\subsection{Fonctions}
\begin{frame}[fragile]
  La fonction \textit{main} est le point d'entr√©e de tout programme Rust.
Chaque fonction est constitu√©e d'une suite de d√©clarations optionnellement suivie par une expression dont le r√©sultat sera la valeur de retour.
\begin{lstlisting}[language=rust]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
\end{lstlisting}  
\end{frame}

\begin{frame}[fragile]
  Une fonction ne se terminant pas par une expression renvoie le type \texttt{()} correspondant au tuple vide.
  \begin{lstlisting}[language=rust]
error[E0308]: mismatched types
 --> src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -> i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
  \end{lstlisting}
\end{frame}

\subsection{Structures de contr√¥le}
\begin{frame}[fragile]
  \frametitle{L'expression \texttt{if}}
Structure conditionnelle classique qui peut √™tre utilis√©e comme une d√©claration ou une expression.
\begin{lstlisting}[language=rust]
{
    let x = 5;
    let number = if x < 1 {
        0
    } else if x > 10 {
        1
    } else {
        2
    };
}
\end{lstlisting}  
\end{frame}
\begin{frame}[fragile]
  \frametitle{Les boucles}
La boucle \texttt{ loop } inconditionnelle
  \begin{lstlisting}[language=rust]
{
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };
}
  \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Les boucles}
  \begin{lstlisting}[language=rust]
let a = [10, 20, 30, 40, 50];

let mut index = 0;
while index < 5 {
    println!("the value is: {}", a[index]);
    index = index + 1;
}

for element in a.iter() {
    println!("the value is: {}", element);
}
for index in 0..5 {
    println!("the value is: {}", a[index]);
}
  \end{lstlisting}
\end{frame}
\subsection{Les structures}

\begin{frame}[fragile]
  \frametitle{D√©finition et instanciation}
Une structure est une composition de donn√©es o√π chaque champs est nomm√© (l'ordre des membres n'est donc pas significatif).
  \begin{lstlisting}[language=rust]
struct Rectangle {
    width: u32,
    height: u32,
}
let r = Rectangle {
    height: 25,
    width: 10,
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{D√©finition de m√©thodes}
\begin{lstlisting}[language=rust, basicstyle=\tiny{}]
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
\end{lstlisting}
Chaque m√©thode a pour premier param√™tre le mot-cl√© \texttt{self}, ce qui permet d'utiliser les champs de la structure depuis laquelle elle est invoqu√©e.
\end{frame}

\begin{frame}[fragile]
  \frametitle{D√©finition de fonctions associ√©es}
On peut √©galement d√©finir des fonctions qui ne s'ex√©cutent pas √† partir d'une instance de structure.
\begin{lstlisting}[language=rust]
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}

let sq = Rectangle::square(3);
\end{lstlisting}  
\end{frame}

\subsection{Les types √©num√©r√©s}

\begin{frame}[fragile]
  \frametitle{D√©finition et instanciation}
  \begin{lstlisting}[language=rust]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

let message = Message::ChangeColor(0,255,255);
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le type \texttt{enum} Option}
  \begin{lstlisting}[language=rust]
enum Option<T> {
    Some(T),
    None,
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le \textit{pattern matching}}
  \begin{lstlisting}[language=rust, basicstyle=\small{}]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{√âxhaustivit√©}
  \begin{lstlisting}[language=rust]
{
    let value = 8;
    match value {
       1 => println!("one"),
       3 => println!("three"),
       5 => println!("five"),
       7 => println!("seven"),
       _ => (),
    }
}
  \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Sucre syntaxique}
  \begin{lstlisting}[language=rust]
let value = Some(14);

match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}

if let Some(3) = value {
    println!("three");
}
  \end{lstlisting}
\end{frame}

\subsection{La gestion des erreurs}

\begin{frame}[fragile]
  \frametitle{Ne pas paniquer !}
  \begin{lstlisting}[language=rust]
fn main() {
    panic!("crash and burn");
}
  \end{lstlisting}
  \begin{lstlisting}[language=bash, basicstyle=\small{}]
> cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo]
        target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn',
        src/main.rs:2:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Erreurs non r√©dhibitoires}
  \begin{lstlisting}[language=rust, basicstyle=\small{}]
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn main() {
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("{:?}", error)
        },
    };
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Raccourcis}
  \begin{lstlisting}[language=rust]
fn main() {
    let f = File::open("hello.txt").unwrap();
}

fn main() {
    let f = File::open("hello.txt")
        .expect("Failed to open hello.txt");
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Propagation des erreurs}
  \begin{lstlisting}[language=rust, basicstyle=\small{}]
fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \begin{lstlisting}[language=rust]
fn read_username_from_file()
        -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
  \end{lstlisting}
\end{frame}
