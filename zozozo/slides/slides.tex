% -*- ispell-dictionary: fr; -*-
\documentclass[10pt]{beamer}
\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{english}
\usepackage{csquotes}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{hyperxmp}
\usepackage[cache=false]{minted}
\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{tikz}
\usepackage{relsize}
\usepackage{multicol}
\usepackage[backend=biber, style=numeric, maxbibnames=99]{biblatex}
\bibliography{slides.bib}

\newcommand\CXX{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{++}}}}

\title{OCaml et la programmation fonctionnelle}
\subtitle{Un fabuleux voyage au cœur de l’informatique (et des monades)}
\date{\today}
\author{Antonin Décimo \and Carine Morel \and Pierre Nigron}
\institute{Université Paris Diderot}

\begin{document}

\maketitle

\begin{frame}{Table des matières}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}

\section{OCaml~: un langage multi-paradigmes}

\begin{frame}[fragile]{OCaml~: un langage fonctionnel}
  \begin{itemize}
  \item<1-> langage à expressions (et pas à instructions)
  \item<2-> fonctions d'ordre supérieur
\begin{minted}{ocaml}
let rec map f l =
match l with
| [] -> []
| h :: t -> f h :: map f t

let l = map (fun x -> x + 1) [1; 2; 3]
(* [2; 3; 4] *)
\end{minted}
  \item<3-> applications partielles
\begin{minted}{ocaml}
let f x y = x * x + y * y
let g = f 2         (* fun y -> 4 + y * y *)
let b = g 3         (* 13 *)
\end{minted}
  \item<4-> filtrage par motifs
    (\begin{english}pattern-matching\end{english}) et types
    algébriques
\begin{minted}{ocaml}
type 'a list = Nil | Cons of 'a * list
type 'a tree = Leaf of 'a
             | Node of 'a tree * 'a tree
\end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{OCaml~: un langage multi-paradigmes}
  Un langage impératif~!
\begin{minted}{ocaml}
let fresh =
  let c = ref (-1) in
  fun () ->
    c := !c + 1;
    !c

fresh ()  (* - : int = 0 *)
fresh ()  (* - : int = 1 *)
\end{minted}

  Un langage à objets~!
\end{frame}

\begin{frame}[fragile]{OCaml~: du typage}
  \begin{itemize}
  \item typage statique (effectué à la compilation)~;
  \item typage fort (pas de transtypage implicite)~;
\begin{minted}{ocaml}
let x = 40 + 2.0
(* Error: This expression has type float but an
   expression was expected of type int *)
\end{minted}
  \item inférence de type~;
\begin{minted}{ocaml}
let l = [1; 2]
(* val l : int list = [1; 2] *)
\end{minted}
  \item du polymorphisme.
\begin{minted}{ocaml}
let rec map f l =
  match l with
  | [] -> []
  | h :: t -> f h :: map f t;;
(* val map : ('a -> 'b) -> 'a list -> 'b list = <fun> *)
    \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}{OCaml~: et plus encore~!}
  \begin{itemize}
  \item compilé ou interprété~;
  \item ramasse-miettes~;
  \item un gestionnaire de paquets~;
  \item possibilité de liaison avec du C.
  \end{itemize}
\end{frame}

\section{Le fonctionnel pur}

\begin{frame}[fragile]{Le fonctionnel pur}
  Un programme fonctionnel pur \emph{n'a pas d'effets de bord}
\begin{minted}{ocaml}
let x = ref 0
let f y = !x * y
  f 2 (* 0 *)
  x := 21
  f 2 (* 42 *)
\end{minted}

  Quelques effets de bords~:
  \begin{itemize}
  \item entrées et sorties (réseau, fichiers, interactions
    utilisateurs, …)~;
  \item les exceptions~;
  \item affectations sur des données mutables.
  \end{itemize}
  Plus généralement~: interaction observable avec le monde extérieur
\end{frame}

\begin{frame}{Le fonctionnel pur, pourquoi~?}
  Comme une fonction mathématique~! La sortie ne dépend que de
  l'entrée.

  Intérêts principaux~:
  \begin{itemize}
  \item facilité à raisonner sur le programme~;
  \item preuves~! (Coq)
  \item possibilité d'optimisations.
  \end{itemize}
\end{frame}

\begin{frame}{Effets de bord et pureté}
  Mais, Carine, comment faire des effets de bord dans un langage
  fonctionnel pur~?
\end{frame}

\section{Les Monades}

\begin{frame}{Les Monades}
  Qu'est-ce~? À quoi ça sert~?
  \begin{itemize}
  \item une façon d’ajouter des effets de bord dans des langages purs
    (monade IO, monade de non-déterminisme)~;
  \item un style de programmation avancé, efficace, et modulaire
    \begin{itemize}
    \item monade d'état, monade liste, monade d'erreur
    \item interpréteur monadique, parseur monadique
    \item monade de continuation, monade d'exception
    \end{itemize}
  \end{itemize}

  Des objets mathématiques (monoïdes dans la 2-catégorie des
  endo-foncteurs)
\end{frame}

\begin{frame}{Les Monades en théorie}
  Soient deux types $A$ et $B$, une monade est~:
  \begin{description}
  \item[un constructeur de type] $M$ qui construit un type monadique
    $M A$~;
  \item[un convertisseur de type]
    $return$ qui encapsule un objet $x$ dans la monade
    \[ return : A \to M A \]
  \item[un combinateur] $bind$ qui transporte un objet d'une monade à
    une autre en le transformant
    \[ bind : M A \to (A \to M B) \to M B \]
  \end{description}
  … satisfaisant certaines lois.
\end{frame}

\begin{frame}[fragile]{Monade~: une signature}
  \begin{minted}{ocaml}
module type Monad = sig
  type 'a t
  val return : 'a -> 'a t
  val bind : 'a t -> ('a -> 'b t) -> 'b t
  (* infix operator for bind *)
  val (>>=) : 'a t -> ('a -> 'b t) -> 'b t
end
  \end{minted}
\end{frame}

\section{Exemple 1 : Monade Maybe}
\begin{frame}[fragile]{La Monade Maybe}
  \begin{minipage}[c]{0.45\linewidth}
    \begin{minted}[fontsize=\small]{ocaml}
module type Monad = sig
 type 'a t
 val return : 'a -> 'a t
 val bind :
 'a t -> ('a -> 'b t) -> 'b t
 val (>>=) :
 'a t -> ('a -> 'b t) -> 'b t
 val _raise : 'a t (* !*)
end
    \end{minted}
  \end{minipage}
  \hfill
  \begin{minipage}[c]{0.45\linewidth}
  \begin{onlyenv}<2->
    \begin{minted}[fontsize=\small]{ocaml}
module Maybe : Monad = struct
  type 'a t = Nothing
            | Just of 'a

  let return x = Just x
  let bind x f = match x with
    | Nothing -> Nothing
    | Just x -> f x
  let (>>=) = bind
  let _raise = Nothing (* !*)
end
    \end{minted}
    \end{onlyenv}
  \end{minipage}
  \onslide<3->{
  \begin{tikzpicture}[scale=1]
    \draw[color=black, fill=cyan!30] (0,0) rectangle (1.5,1.5) ;
    \draw (0.75,1.5) node[above]{Just x};
    \node[text centered] at (0.75,0.75) {x};

    \draw[color=black, fill=orange!30] (2,0) rectangle (3.5,1.5) ;
    \draw (2.75,1.5) node[above]{Nothing};
  \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]{La Monade Maybe~: utilisation}
  \begin{minipage}[c]{0.45\linewidth}
    \begin{minted}[fontsize=\small]{ocaml}
let div x y =
  if y = 0 then Nothing
  else Just (x/y)

let divM x y =
  if y = 0 then _raise
  else return (x/y)
    \end{minted}
    \pause{}
    \begin{minted}[fontsize=\small]{ocaml}
(* (((x / y1) / y2) / y3)) *)
let divM_1 x y1 y2 y3 =
  match divM x y1 with
  | Nothing -> Nothing
  | Just r1 ->
     match divM r1 y2 with
     | Nothing -> Nothing
     | Just r2 -> divM r2 y3
\end{minted}
  \end{minipage}
  \hfill
  \begin{minipage}[c]{0.45\linewidth}
    \pause{}
    \begin{minted}[fontsize=\small]{ocaml}
let divM_2 x y1 y2 y3 =
  bind (divM x y1)  (fun r2 ->
  bind (divM r2 y2) (fun r3 ->
  divM r3 y3))
    \end{minted}
    \pause{}
    \begin{minted}[fontsize=\small]{ocaml}
let divM_3 x y1 y2 y3 =
  divM x y1
  >>= fun r2 -> divM r2 y2
  >>= fun r3 -> divM r3 y3
    \end{minted}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]{La Monade Maybe~: explications}
  \begin{multicols}{2}
    \scalebox{0.65}{
      \begin{tikzpicture}[scale=1]
        %%
        \draw[color=black] (-0.25,-0.25) rectangle (1.75,3.75) ;

        \draw[color=black, fill=cyan!30] (0,2) rectangle (1.5,3.5) ;
        \node[text centered] at (0.75,2.75) {r2};
        \draw (0.75,1.5) node[above]{\small divM\_3 x y1} ;
        \draw[color=black, fill=orange!30] (0,0) rectangle (1.5,1.5) ;

        \draw[thick, ->,>=latex] (1.5,2.75) -- (3, 2.75);
        \draw[thick, ->,>=latex] (1.5,2.75) -- (3, 4.75);
        \draw[thick, ->,>=latex] (1.5,0.75) -- (6, 0.75);

        %%
        \draw[color=black] (2.75, 1.75) rectangle (4.75,5.75) ;

        \draw[color=black, fill=cyan!30] (3,4) rectangle (4.5,5.5) ;
        \node[text centered] at (3.75,4.75) {r3};
        \draw (3.75,3.5) node[above]{\small divM\_3 r2 y2} ;
        \draw[color=black, fill=orange!30] (3,2) rectangle (4.5,3.5) ;

        \draw[thick, ->,>=latex] (4.5,2.75) -- (6, 2.75);
        \draw[thick, ->,>=latex] (4.5,4.75) -- (6, 4.75);
        \draw[thick, ->,>=latex] (4.5,4.75) -- (6, 6.75);
        %%
        \draw[color=black] (5.75, 3.75) rectangle (7.75,7.75) ;

        \draw[color=black, fill=cyan!30] (6,6) rectangle (7.5,7.5) ;
        \node[text centered] at (6.75,6.75) {r4};
        \draw (6.75,5.5) node[above]{\small divM\_3 r3 y3} ;
        \draw[color=black, fill=orange!30] (6,4) rectangle (7.5,5.5) ;

        \draw[color=black, fill=orange!30] (6,2) rectangle (7.5,3.5) ;

        \draw[color=black, fill=orange!30] (6,0) rectangle (7.5,1.5) ;
      \end{tikzpicture}
    }
\begin{minted}{ocaml}
let divM_3 x y1 y2 y3 =
  divM x y1
  >>= fun r2 -> divM r2 y2
  >>= fun r3 -> divM r3 y3
\end{minted}
    \pause{}
\begin{minted}{ocaml}
let divM_4 x y1 y2 y3 =
  return x
  >>= fun r1 -> divM r1 y1
  >>= fun r2 -> divM r2 y2
  >>= fun r3 -> divM r3 y3
\end{minted}
  \end{multicols}
\end{frame}

\begin{frame}[fragile]{La Monade Maybe~: le bilan}
  \begin{minipage}[c]{0.45\linewidth}
\begin{minted}[fontsize=\small]{ocaml}
(* style usuel *)
let divM_1 x y1 y2 y3 =
  match divM x y1 with
  | Nothing -> Nothing
  | Just r1 ->
     match divM r1 y2 with
     | Nothing -> Nothing
     | Just r2 -> divM r2 y3
\end{minted}
  \end{minipage}
  \hfill
  \begin{minipage}[c]{0.45\linewidth}
\begin{minted}[fontsize=\small]{ocaml}
(* style monadique *)
let divM_3 x y1 y2 y3 =
  divM x y1
  >>= fun r2 -> divM r2 y2
  >>= fun r3 -> divM r3 y3
\end{minted}
  \end{minipage}
\end{frame}

\section{Exemple 2 : Monade Random}

\begin{frame}[fragile]{La Monade Random}
  \begin{multicols*}{2}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
type seed = Seed of int
type 'a monad =
  seed -> 'a * seed

let return a =
  fun (Seed s)->(a,Seed s)

let bind (step:'a monad)
      (f:'a -> 'b monad)
    :'b monad=
  (fun (Seed s) ->
    let i, s' = step (Seed s)
    in f i s')

let (>>=) = bind
\end{minted}
    \columnbreak{}
    \pause{}
    \begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let next (Seed s) =
  Seed (s*23 mod 17+1)
let rand (Seed s) = s - 1

let random:int monad =
  (fun (s:seed) ->
    (rand s, next s))

let run f =
  let seed = Random.int 17 + 1 in
  fst (f (Seed seed))
\end{minted}
  \end{multicols*}
  \begin{center}
    \begin{tikzpicture}[scale=1]
      \draw (0.75,1.5) node[above]{\verb|fun s -> (i, s')|};
      \draw[color=black, fill=cyan!30] (0,0) rectangle (1.5,1.5) ;
      \draw[color=black, fill=white] (1,1) rectangle (1.5,1.5) ;
      \node[text centered] at (1.25,1.25) {\footnotesize s'};
      \node[text centered] at (0.75,0.75) {i};
      \draw[thick, ->,>=latex] (-0.5,1) to[bend left] (0, 0.75);
      \draw (-0.5,1) node[left]{s} ;
    \end{tikzpicture}
    \begin{tikzpicture}[scale=1]
      \draw (0.75,1.5) node[above]{random};
      \draw[color=black, fill=cyan!30] (0,0) rectangle (1.5,1.5) ;
      \draw[color=black, fill=white] (0.7,1) rectangle (1.5,1.5) ;
      \node[text centered] at (1.1,1.25) {\footnotesize next s};
      \node[text centered] at (0.75,0.75) {rand s};
      \draw[thick, ->,>=latex] (-0.5,1) to[bend left] (0, 0.75);
      \draw (-0.5,1) node[left]{s} ;
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]{La Monade Random~: les paires}
  \begin{minipage}[l]{0.45\linewidth}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
type seed = Seed of int
type 'a monad =
  seed -> 'a * seed

let random:int monad =
  (fun (s:seed) ->
    (rand s, next s))

let return a =
  fun (Seed s)->(a,Seed s)

let bind (step:'a monad)
      (f:'a -> 'b monad)
    :'b monad=
  (fun (Seed s) ->
    let i, s' = step (Seed s)
    in f i s')

let (>>=) = bind

let run f =
  let seed = Random.int 17 + 1
  in fst (f (Seed seed))
\end{minted}
  \end{minipage}
  \hfill
  \begin{minipage}[r]{0.45\linewidth}
  \pause{}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let rand_int () = run random

let mk_pair' =
  fun seed ->
  bind
    random
    (fun x seed' ->
      bind
        random
        (fun y -> return (x, y))
        seed')
    seed

let mk_pair =
  random >>= fun x ->
  random >>= fun y ->
  return (x, y)

let rand_pair () = run mk_pair
\end{minted}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]{La Monade Random~: les paires}
  \begin{multicols*}{2}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let rand_int () = run random

let mk_pair' =
  fun seed ->
  bind
    random
    (fun x seed' ->
      bind
        random
        (fun y -> return (x, y))
        seed')
    seed
\end{minted}
    \columnbreak{}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let mk_pair =
  random >>= fun x ->
  random >>= fun y ->
  return (x, y)

let rand_pair () = run mk_pair
\end{minted}
  \end{multicols*}
  \begin{center}
    \begin{tikzpicture}[scale=1]
      \draw[color=black, fill=cyan!30] (0,0) rectangle (1.5,1.5) ;
      \draw[color=black, fill=white] (1,1) rectangle (1.5,1.5) ;
      \node[text centered] at (1.25,1.25) {\footnotesize s'};
      \node[text centered] at (0.75,0.75) {x};
      \draw[thick, ->,>=latex] (-0.5,1) to[bend left] (0, 0.75);
      \draw (-0.5,1) node[left]{s} ;
      \draw (0.75,0) node[below]{random} ;
      %
      \draw[color=black, fill=cyan!30] (3,0) rectangle (4.5,1.5) ;
      \draw[color=black, fill=white] (4,1) rectangle (4.5,1.5) ;
      \node[text centered] at (4.25,1.25) {\footnotesize s''};
      \node[text centered] at (3.75,0.75) {y};
      \draw (3.75,0) node[below]{random} ;
      %
      \draw[color=black, fill=cyan!30] (6,0) rectangle (7.5,1.5) ;
      \draw[color=black, fill=white] (7,1) rectangle (7.5,1.5) ;
      \node[text centered] at (7.25,1.25) {\footnotesize s''};
      \node[text centered] at (6.75,0.75) {(x, y)};
      \draw (6.75,0) node[below]{return} ;

      \draw[thick, ->,>=latex] (0.75,1.5) to[bend left](3.75, 1.5);
      \draw (2.25,2) node[above]{\verb|>>=|} ;
      \draw[thick, ->,>=latex] (3.75,1.5) to[bend left] (6.75, 1.5);
      \draw (5.25,2) node[above]{\verb|>>=|} ;
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]{La Monade Random~: les listes}
  \begin{multicols*}{2}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
type seed = Seed of int
type 'a monad =
  seed -> 'a * seed

let random:int monad =
  (fun (s:seed) ->
    (rand s, next s))

let return a =
  fun (Seed s)->(a,Seed s)

let bind (step:'a monad)
      (f:'a -> 'b monad)
    :'b monad=
  (fun (Seed s) ->
    let i, s' = step (Seed s)
    in f i s')

let (>>=) = bind

let run f =
  let seed = Random.int 17 + 1
  in fst (f (Seed seed))
\end{minted}
    \columnbreak{}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let rec mk_list n =
  if n = 0 then return [] else
    random >>= fun x ->
    mk_list (n-1) >>=  fun l ->
    return (x::l)

let rand_list () =
  run (random >>= fun l->mk_list l)
\end{minted}
  \end{multicols*}
\end{frame}

\begin{frame}[fragile]{La Monade Random~: les listes}
  \begin{center}
\begin{minted}[baselinestretch=0.8,fontsize=\small]{ocaml}
let rec mk_list n =
  if n = 0 then return [] else
    random >>= fun x ->
    mk_list (n-1) >>=  fun l ->
    return (x::l)

let rand_list () =
  run (random >>= fun l->mk_list l)
\end{minted}
    \begin{tikzpicture}[scale=1]
      \draw[color=black, fill=cyan!30] (-0.25,-0.25) rectangle (1.75,1.75) ;
      \draw[color=black, fill=white] (1.25,1.25) rectangle (1.75,1.75) ;
      \node[text centered] at (1.5,1.5) {\footnotesize $s_1$};
      \node[text centered] at (0.75,0.75) {$x_1$};
      \draw[thick, ->,>=latex] (-0.75,1.) to[bend left] (-0.25,0.75);
      \draw (-0.75,1.) node[left]{s} ;
      \draw (0.75,-0.25) node[below]{random} ;
      %
      \draw[color=black] (2.75, -0.7) rectangle (10,2) ;
      \draw (6,-0.7) node[below]{return} ;
      \draw[color=black, fill=cyan!30] (3,0) rectangle (4.5,1.5) ;
      \draw[color=black, fill=white] (4,1) rectangle (4.5,1.5) ;
      \node[text centered] at (4.25,1.25) {\footnotesize $s_2$};
      \node[text centered] at (3.75,0.75) {$x_2$};
      \draw (3.75,0) node[below]{\small random} ;
      %
      \draw[color=black] (5.25, -0.25) rectangle (9.75,1.75) ;
      \draw (7.375,-0.25) node[below]{\small return} ;
      \draw[color=black, fill=cyan!30] (5.5,0.25) rectangle (6.75,1.5) ;
      \draw[color=black, fill=white] (6.375,1.125) rectangle (6.75,1.5) ;
      \node[text centered] at (6.6,1.25) {\footnotesize $s_3$};
      \node[text centered] at (6.125,0.825) {\small $x_3$};
      \draw (6.125,0.25) node[below]{\footnotesize random} ;

      \draw[color=black] (7.375, 0.125) rectangle (9.5,1.375) ;
      \draw (8.4,0.125) node[below]{\footnotesize return} ;
      \draw[color=black, fill=cyan!30] (7.5, 0.25) rectangle (8.5,1.25) ;
      \draw[color=black, fill=white] (8.25,1.) rectangle (8.5,1.25) ;
      \node[text centered] at (8,0.75) {\footnotesize $x_4$};
      %

      \draw[thick, ->,>=latex] (0.75,1.75) to[bend left](3.75, 2);
      \draw (2.25,2.25) node[above]{\verb|>>=|} ;
      \draw[thick, ->,>=latex] (3.75,1.5) to[bend left] (5.75, 1.75);
      \draw (5,1.9) node[above]{\small\verb|>>=|} ;
      \draw[thick, ->,>=latex] (6.125,1.5) to[bend left] (8, 1.375);
      \draw (7.075,1.7) node[above]{\footnotesize\verb|>>=|} ;

      \draw (9,0.6) node[above]{ ...} ;

    \end{tikzpicture}
  \end{center}
\end{frame}

\section{Conclusion}

\begin{frame}{La programmation fonctionnelle}
  Un style de programmation qui se concentre sur l'algorithme.

  De l'expressivité, de la concision.

  De la puissance pour tous les types de programmeurs, allant du L1 à
  Yann Régis-Gianas.
\end{frame}

\begin{frame}{Les Monades}
  Un outil extrêmement puissant, mais difficile à saisir.

  \begin{itemize}
  \item permet d'avoir des effets de bord en gardant les bonnes
    propriétés de la programmation fonctionnelle pure;
  \item mais aussi une sorte de patron de conception aux stéroïdes.
  \end{itemize}
  \begin{alertblock}{Mais surtout}<2->
      Pas indispensable pour faire de la
      programmation fonctionnelle (il y a des librairies !)
  \end{alertblock}
\end{frame}

\begin{frame}{La programmation fonctionnelle à l'horizon}
  Est-elle réservée aux langages fonctionnels~?
  \begin{itemize}
  \item \CXX{} \mintinline{cpp}|std::functional|, Java lambda, Golang, Rust, …
  \item C \inputminted{c}{./attributes.c}
  \end{itemize}

  ExCamera~\cite{fouladi2017encoding}: un encodeur vidéo en \CXX{},
  fonctionnel pur
\end{frame}

\begin{frame}[allowframebreaks]
  \nocite{*}
  \printbibliography{}
\end{frame}

\end{document}
